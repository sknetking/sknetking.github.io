<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Chat with Audio Calling</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .control-panel {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        input, button {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        button {
            background: #4285f4;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background: #3367d6;
        }
        button:disabled {
            background: #cccccc;
        }
        #messages {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
            background: white;
            border-radius: 4px;
        }
        .call-controls {
            margin-top: 15px;
            text-align: center;
        }
        .call-btn {
            background: #34a853;
            margin: 0 5px;
        }
        .end-call-btn {
            background: #ea4335;
        }
        .answer-call-btn {
            background: #fbbc05;
        }
        small {
            color: #666;
        }
        .peer-info {
            margin-bottom: 10px;
            font-weight: bold;
        }
        .call-notification {
            background: #fbbc05;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            text-align: center;
            display: none;
        }
        .audio-container {
            margin-top: 15px;
            text-align: center;
        }
        #remoteAudio {
            width: 100%;
            background: #f0f0f0;
            border-radius: 5px;
        }
        .peers-panel {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        #peersList {
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
        }
        .peer-item {
            padding: 8px;
            margin: 5px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        .peer-item:hover {
            background-color: #e6f2ff;
        }
        .peer-name {
            font-weight: bold;
        }
        .peer-id {
            color: #666;
            font-size: 0.8em;
        }
        .peer-status {
            float: right;
            font-size: 0.8em;
            color: #34a853;
        }
        .peer-offline {
            color: #ea4335;
        }
    </style>
</head>
<body>
    <div class="main-chatbox container">
        <h1>P2P Chat with Audio Calling</h1>
        
        <div class="control-panel">
            <div class="peer-info">
                <div>Your ID: <span id="yourId">Generating...</span></div>
                <div>Your Name: <input type="text" id="userNameInput" placeholder="Your name"></div>
                <div>Connected to: <span id="peerName">None</span></div>
            </div>
        </div>
        
        <div class="peers-panel">
            <h3>Available Peers</h3>
            <div id="peersList">Loading peers...</div>
            <button id="refreshPeersBtn">Refresh List</button>
            <small>Peers will appear when they're online</small>
        </div>
        
        <div id="messages"></div>
        
        <div>
            <input type="text" id="messageInput" placeholder="Type your message" disabled>
            <button id="sendBtn" disabled>Send</button>
        </div>
        
        <div class="call-notification" id="callNotification">
            <p>Incoming call from <span id="callerName"></span></p>
            <button id="answerCallBtn" class="answer-call-btn">Answer</button>
            <button id="rejectCallBtn" class="end-call-btn">Reject</button>
        </div>
        
        <div class="call-controls">
            <button id="callBtn" class="call-btn" disabled>Start Audio Call</button>
            <button id="endCallBtn" class="end-call-btn" disabled>End Call</button>
        </div>
        
        <div class="audio-container">
            <audio id="remoteAudio" controls></audio>
        </div>
        
        <audio id="myAudio" style='display:none;' controls loop>
            <source src="https://github.com/sknetking/useascdn/raw/refs/heads/main/original-phone-ringtone.mp3" type="audio/ogg">
            <source src="https://github.com/sknetking/useascdn/raw/refs/heads/main/original-phone-ringtone.mp3" type="audio/mpeg">
            Your browser does not support the audio element.
        </audio>
    </div>
    
    <h2>How to use it</h2>
    <p>
        <b>P2P Chat with Audio Calling</b><br>
        This is a simple peer-to-peer chat demo app with built-in audio calling. To use it, both users open the same link,<br>
        enter their name, and select a peer from the list to connect. Once connected,<br>
        they can exchange messages and start an audio call in real-time ‚Äî no server needed for chat or calling.<br>
    </p>
    <mark>Note: Your chat data is not stored anywhere and your audio is end-to-end encrypted. This is a serverless WebRTC application.</mark>

    <script>
    // Configuration - YOU MUST SET THESE VALUES
    const GIST_ID = 'bdbdba4a9f0494c4f04615b0fd4dcc99'; // Replace with your Gist ID
    const GIST_FILENAME = 'mydb.json';
    const PEER_UPDATE_INTERVAL = 30000; // 30 seconds
    const GIST_TOKEN = getGitHubToken();
    const GIST_ID = getGistId();

    // DOM elements
    const yourIdEl = document.getElementById('yourId');
    const peerNameEl = document.getElementById('peerName');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const messagesEl = document.getElementById('messages');
    const callBtn = document.getElementById('callBtn');
    const endCallBtn = document.getElementById('endCallBtn');
    const callNotification = document.getElementById('callNotification');
    const answerCallBtn = document.getElementById('answerCallBtn');
    const rejectCallBtn = document.getElementById('rejectCallBtn');
    const callerNameEl = document.getElementById('callerName');
    const remoteAudio = document.getElementById('remoteAudio');
    const audio = document.getElementById("myAudio");
    const peersListEl = document.getElementById('peersList');
    const refreshPeersBtn = document.getElementById('refreshPeersBtn');
    const userNameInput = document.getElementById('userNameInput');
    
    // Application state
    let peer;
    let conn;
    let currentStream;
    let call;
    let incomingCall = null;
    let myPeerInfo = {
        id: '',
        name: '',
        lastSeen: 0
    };
    let knownPeers = {};
    let peerUpdateInterval;
    const STORAGE_KEY = 'peerjs_custom_id';
    const NAME_STORAGE_KEY = 'peerjs_custom_name';
    
    // Initialize the application
    initialize();
    
    function initialize() {
        // Load saved name if exists
        const storedName = localStorage.getItem(NAME_STORAGE_KEY);
        if (storedName) {
            userNameInput.value = storedName;
            myPeerInfo.name = storedName;
        }
        
        // Set up event listeners
        userNameInput.addEventListener('change', updateUserName);
        refreshPeersBtn.addEventListener('click', updatePeerPresence);
        sendBtn.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });
        callBtn.addEventListener('click', startCall);
        endCallBtn.addEventListener('click', endCall);
        answerCallBtn.addEventListener('click', answerCall);
        rejectCallBtn.addEventListener('click', rejectCall);
        
        // Initialize PeerJS connection
        createPeerConnection();
    }
    
    function updateUserName() {
        const newName = userNameInput.value.trim();
        if (newName) {
            myPeerInfo.name = newName;
            localStorage.setItem(NAME_STORAGE_KEY, newName);
            
            // Update in Gist if we're already registered
            if (myPeerInfo.id) {
                updatePeerPresence();
            }
            
            // Update current connection if exists
            if (conn && conn.open) {
                conn.send(JSON.stringify({ type: 'name', name: newName }));
            }
        }
    }
    
    function createPeerConnection(customId) {
        if (peer && !peer.destroyed) peer.destroy();
        
        peer = new Peer(customId, {
            host: '0.peerjs.com',
            port: 443,
            path: '/',
            secure: true,
            debug: 2,
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    {
                        urls: 'turn:numb.viagenie.ca',
                        credential: 'webrtc',
                        username: 'webrtc@live.com'
                    }
                ]
            }
        });
        
        peer.on('open', id => {
            yourIdEl.textContent = id;
            myPeerInfo.id = id;
            localStorage.setItem(STORAGE_KEY, id);
            logMessage(`‚úÖ Your ID: ${id}`);
            
            // Start peer discovery
            startPeerDiscovery();
        });
        
        peer.on('connection', connection => {
            conn = connection;
            setupConnection();
            
            // Exchange names
            setTimeout(() => {
                if (conn.open) {
                    conn.send(JSON.stringify({ 
                        type: 'name', 
                        name: myPeerInfo.name || myPeerInfo.id 
                    }));
                }
            }, 500);
        });
        
        peer.on('call', incoming => {
            incomingCall = incoming;
            callerNameEl.textContent = remotePeerName || incoming.peer;
            callNotification.style.display = 'block';
            playAudio();
            logMessage("üìû Incoming call...");
        });
        
        peer.on('error', err => {
            console.error(err);
            if (err.type === 'unavailable-id') {
                logMessage(`‚ùå ID "${customId}" is already taken.`);
                localStorage.removeItem(STORAGE_KEY);
            } else {
                logMessage(`‚ùå PeerJS error: ${err.type}`);
            }
        });
        
        peer.on('disconnected', () => {
            logMessage("‚ö†Ô∏è Connection lost. Attempting to reconnect...");
            peer.reconnect();
        });
        
        peer.on('close', () => {
            logMessage("‚ùå Peer connection closed");
        });
    }
    
    function startPeerDiscovery() {
        // Update immediately and then at regular intervals
        updatePeerPresence();
        peerUpdateInterval = setInterval(updatePeerPresence, PEER_UPDATE_INTERVAL);
    }
    
    async function updatePeerPresence() {
        if (!myPeerInfo.id) return;
        
        myPeerInfo.lastSeen = Date.now();
        
        try {
            // First try to get existing gist
            const response = await fetch(`https://api.github.com/gists/${GIST_ID}`);
            const gist = await response.json();
            
            let peers = {};
            if (gist.files && gist.files[GIST_FILENAME]) {
                peers = JSON.parse(gist.files[GIST_FILENAME].content);
            }
            
            // Update with our info
            peers[myPeerInfo.id] = {
                name: myPeerInfo.name || myPeerInfo.id,
                lastSeen: myPeerInfo.lastSeen
            };
            
            // Clean up old peers (older than 5 minutes)
            const now = Date.now();
            Object.keys(peers).forEach(peerId => {
                if (now - peers[peerId].lastSeen > 300000) { // 5 minutes
                    delete peers[peerId];
                }
            });
            
            // Update gist
            await fetch(`https://api.github.com/gists/${GIST_ID}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'token ${GIST_TOKEN}' // Will be replaced by GitHub Actions
                },
                body: JSON.stringify({
                    files: {
                        [GIST_FILENAME]: {
                            content: JSON.stringify(peers, null, 2)
                        }
                    }
                })
            });
            
            updatePeersList(peers);
        } catch (err) {
            console.error('Failed to update peer presence:', err);
            peersListEl.innerHTML = 'Failed to load peers. Refresh to try again.';
        }
    }
    
    function updatePeersList(peers) {
        knownPeers = peers;
        
        if (Object.keys(peers).length === 0) {
            peersListEl.innerHTML = 'No other peers online';
            return;
        }
        
        let peersHTML = '';
        Object.keys(peers).forEach(peerId => {
            if (peerId === myPeerInfo.id) return; // Don't show self
            
            const peer = peers[peerId];
            const isOnline = (Date.now() - peer.lastSeen) < 120000; // 2 minutes
            
            peersHTML += `
                <div class="peer-item" data-peer-id="${peerId}">
                    <div>
                        <span class="peer-name">${peer.name || 'Anonymous'}</span>
                        <span class="peer-status ${isOnline ? '' : 'peer-offline'}">
                            ${isOnline ? 'online' : 'offline'}
                        </span>
                    </div>
                    <div class="peer-id">${peerId}</div>
                </div>
            `;
        });
        
        peersListEl.innerHTML = peersHTML || 'No other peers online';
        
        // Add click handlers
        document.querySelectorAll('.peer-item').forEach(item => {
            item.addEventListener('click', () => {
                const peerId = item.getAttribute('data-peer-id');
                connectToPeer(peerId);
            });
        });
    }
    
    function connectToPeer(peerId) {
        if (!peer.open) {
            logMessage("‚è≥ Waiting for peer to be ready...");
            peer.once('open', () => {
                conn = peer.connect(peerId);
                setupConnection();
            });
        } else {
            conn = peer.connect(peerId);
            setupConnection();
        }
    }
    
    function setupConnection() {
        conn.on('open', () => {
            logMessage("üîå Connected to peer!");
            messageInput.disabled = false;
            sendBtn.disabled = false;
            callBtn.disabled = false;
            
            // Send our name
            conn.send(JSON.stringify({ 
                type: 'name', 
                name: myPeerInfo.name || myPeerInfo.id 
            }));
        });
        
        conn.on('data', data => {
            try {
                const parsed = JSON.parse(data);
                if (parsed.type === 'name') {
                    remotePeerName = parsed.name;
                    peerNameEl.textContent = remotePeerName;
                }
            } catch {
                const displayName = remotePeerName ? `${remotePeerName}` : conn.peer;
                logMessage(`${displayName}: ${data}`);
            }
        });
        
        conn.on('close', () => {
            logMessage("‚ùå Disconnected");
            messageInput.disabled = true;
            sendBtn.disabled = true;
            callBtn.disabled = true;
            endCallBtn.disabled = true;
            peerNameEl.textContent = 'None';
            callNotification.style.display = 'none';
            if (call) endCall();
        });
        
        conn.on('error', err => {
            logMessage(`‚ùå Connection error: ${err}`);
        });
    }
    
    function sendMessage() {
        const msg = messageInput.value.trim();
        if (msg && conn?.open) {
            conn.send(msg);
            logMessage(`You: ${msg}`);
            messageInput.value = '';
        }
    }
    
    function logMessage(msg, from = null) {
        const now = new Date().toLocaleTimeString();
        const div = document.createElement('div');
        div.innerHTML = from
            ? `<small>[${now}]</small> <strong>${from}:</strong> ${msg}`
            : `<small>[${now}]</small> ${msg}`;
        messagesEl.appendChild(div);
        messagesEl.scrollTop = messagesEl.scrollHeight;
    }
    
    function playAudio() {
        audio.play().catch(e => console.log('Audio play failed:', e));
    }
    
    function stopAudio() {
        audio.pause();
        audio.currentTime = 0;
    }
    
    function answerCall() {
        if (!incomingCall) return;
        
        navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
            currentStream = stream;
            call = incomingCall;
            call.answer(stream);
            setupCall();
            callNotification.style.display = 'none';
            logMessage("üìû Call answered");
            stopAudio();
        }).catch(err => {
            logMessage(`‚ùå Error accessing mic: ${err.message}`);
            callNotification.style.display = 'none';
            stopAudio();
        });
    }
    
    function rejectCall() {
        if (incomingCall) {
            incomingCall.close();
            incomingCall = null;
        }
        callNotification.style.display = 'none';
        logMessage("üìû Call rejected");
        stopAudio();
    }
    
    function startCall() {
        if (!conn || !conn.open) {
            logMessage("‚ùå Not connected to any peer");
            return;
        }
        
        navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
            currentStream = stream;
            call = peer.call(conn.peer, stream);
            setupCall();
            logMessage("üìû Calling...");
        }).catch(err => {
            logMessage(`‚ùå Cannot access mic: ${err.message}`);
        });
    }
    
    function setupCall() {
        call.on('stream', remoteStream => {
            remoteAudio.srcObject = remoteStream;
            remoteAudio.play().catch(e => console.warn('Audio play failed:', e));
            callBtn.disabled = true;
            endCallBtn.disabled = false;
            logMessage("üéß Connected to call");
        });
        
        call.on('close', () => {
            endCall();
            logMessage("üìû Call ended");
        });
        
        call.on('error', err => {
            logMessage(`‚ùå Call error: ${err.message}`);
            endCall();
        });
    }
    
    function endCall() {
        if (call) {
            call.close();
            call = null;
        }
        if (currentStream) {
            currentStream.getTracks().forEach(t => t.stop());
            currentStream = null;
        }
        callBtn.disabled = false;
        endCallBtn.disabled = true;
        remoteAudio.srcObject = null;
    }
    
    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
        if (peer && !peer.destroyed) peer.destroy();
        if (conn && conn.open) conn.close();
        endCall();
        clearInterval(peerUpdateInterval);
    });
    </script>
</body>
</html>
